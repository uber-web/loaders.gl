# About Compressed Textures

**Compressed textures** are different from compressed images in that they do not have to be decompressed, they can be used directly by a supporting GPU. A compressed texture typically consists of a collection of compressed subimages, representing mipmaps etc. These compressed subimages extracted as binary blobs by loaders.gl, intended to be passed directly to a GPU that understands how to read them. Only the container file is parsed, extracting metadata and the binary buffers representing subimages.

**Supercompressed textures** can be cheaply transcoded to different compressed texture formats without first decompressing and then recompressing the texture. This allows a single supercompressed texture to be portbably used on multiple platforms even though those platforms do not support the same compressed texture formats.

## Performance Considerations

Advantages:

- Compressed textures can allow a lot more textures (~4x) to be stored in the same amount of GPU memory, which can make a big difference, decreasing memory bandwidth use, or allowing more detail, also mobile devices tend to crash when memory fills up.
- Compressed textures do not need to be decoded before use which reduces CPU load, noticable when many textures are loaded.
- Compressed textures include mipmaps, further reducing CPU load by avoiding mipmap generation step, noticable when many textures are loaded.

On the downside:

- Compressed textures can be somewhat bigger and slower than JPEGs to load over the network. Actual number should be verified but as an example, compressed texture formats might achieve about 4-6x compression, compared to say 15x compression for JPEG.
- Compression tends to be relatively slow. In combination with some IP issues this usually makes it impractical to create GPU compressed textures on the fly.
- Since different devices have different GPUs that support different compressed texture formats, one typically has to provide compressed textures in multiple formats and decide which ones to load at runtime (although basis avoids this problem).

## Container Formats

> [Texture Containers](http://www.devans.xyz/2017/04/04/texture-containers.html) This section is based on the information in Dave Evan's helpful Texture Containers article, please refer to it for additional details.

Non-texture image formats do not support storing mipmap chains. When loading a JPG or a PNG, mipmaps must be generated by resizing the original image repeatedly for each required mipmap level.

In contrast, a single texture container can store all the data required for an entire texture, mipmaps, array layers or cubemap faces. Generating mipmaps offline is important if you use compressed textures, as it’s generally impractical to generate compressed textures at runtime.

The main container formats for compressed textures are the Khronos Texture format (KTX) and Microsoft's DirectDraw Surface (DDS). KTX, being a standard, is better specified and therefore recommended.

### KTX (Khronos Texture)

The KTX format is a Khronos Group standard for storing textures. It can store 1D, 2D, 3D, Cubemaps and Array Textures, along with any number of mipmaps for these textures. This makes it ideal for storing almost any kind of texture you could want.

The fields in the KTX header are directly compatible with other Khronos standards such as WebGL. The texture data is described in the `glType`, `glFormat`, `glInternalFormat`, and `glBaseInternalFormat` header fields. These should match up with the parameters to the `gl[Compressed]Tex[Sub]Image*` calls used to submit each texture mipmap level’s data.

- [Khronos KTX Specification](http://github.khronos.org/KTX-Specification)
- [Khronos KTX Software](https://github.com/KhronosGroup/KTX-Software)

### DDS (DirectDraw Surface)

The DDS format is in common use for storing textures (despite DirectDraw being long deprecated). Originally only 2D textures were supported, but the D3D10 header extension added support for texture arrays and D3D10+ features. The format is partially documented on MSDN.

- [MSDN: Programming Guide for DDS](https://docs.microsoft.com/en-us/windows/win32/direct3ddds/dx-graphics-dds-pguide)

### PVR (PowerVR)

The PVR texture compression format defines its own container

http://cdn.imgtec.com/sdk-documentation/PVR+File+Format.Specification.pdf

## Compression Formats

As mentioned the actual compressed subimages are not parsed or modified by loaders.gl, however loaders.gl attempts to identify the formats using metadata and return the appropiate format fields to facilitate use in WebGL and WebGPU.

The following is the typical list of compressed texture formats, which loaders.gl can properly tag:

| Format                                               | Description                 |
| ---------------------------------------------------- | --------------------------- |
| [`S3TC]() | S3 texture compression formats           |
| [`S3TC_SRGB]() | S3 SRGB texture compression formats |
| [`PVRTC]() | PowerVR texture compression formats     |
| [`ETC1]() | texture compression formats              |
| [`ETC]() | texture compression formats               |
| [`ASTC`]()                                           | texture compression formats |
| [`ATC]() | AMD texture compression formats           |

## Using Compressed Textures

Compressed textures are designed to be directly uploaded to GPUs that have the required decoding support implemented in hardware.

### Using compressed textures in JS

loaders.gl currently does not contain general software decoding capabilities for compressed textures, meaning that they can only be uploaded directly to supporting GPUs.

### Using Compressed Textures in luma.gl

luma.gl (and by extension other vis.gl frameworks like deck.gl) are designed to integrate seamlessly with loaders.gl.

Accordingly, the data returned by any "image" category loader can be passed directly to

### Using Compressed Textures in WebGL

To use compressed textures in WebGL

```js
const texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);

gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

for (let index = 0; index < images.length; ++index) {
  const image = images[index];
  const {width, height, format, data} = image;

  gl.compressedTexImage2D(gl.TEXTURE_2D, index, format, width, height, 0, data);
}

if (images.length > 1) {
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
} else {
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
}
```

### WebGL Extensions

Used to query if the GPU supports specific proprietary compressed texture formats.

| Extension                                                                                                                    | Enables                             |
| ---------------------------------------------------------------------------------------------------------------------------- | ----------------------------------- |
| [`WEBGL_compressed_texture_s3tc`\(https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc)           | S3 texture compression formats      |
| [`WEBGL_compressed_texture_s3tc_srgb`\(https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb) | S3 SRGB texture compression formats |
| [`WEBGL_compressed_texture_atc`\(https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_atc)             | AMD texture compression formats     |
| [`WEBGL_compressed_texture_pvrtc`\(https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc)         | PowerVR texture compression formats |
| [`WEBGL_compressed_texture_etc1`\(https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1)           | texture compression formats         |
| [`WEBGL_compressed_texture_etc`\(https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc)             | texture compression formats         |
| [`WEBGL_compressed_texture_astc`\(https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc)           | texture compression formats         |

### Using Compressed Textures in WebGPU

TBA - Support for compressed textures is a work in progress in the [WebGPU standard](https://gpuweb.github.io/gpuweb/#texture-formats).

It looks like S3 texture compression

```js
    // BC compressed formats usable if "texture-compression-bc" is both
    // supported by the device/user agent and enabled in requestDevice.
    "bc1-rgba-unorm",
    "bc1-rgba-unorm-srgb",
    "bc2-rgba-unorm",
    "bc2-rgba-unorm-srgb",
    "bc3-rgba-unorm",
    "bc3-rgba-unorm-srgb",
    "bc4-r-unorm",
    "bc4-r-snorm",
    "bc5-rg-unorm",
    "bc5-rg-snorm",
    "bc6h-rgb-ufloat",
    "bc6h-rgb-float",
    "bc7-rgba-unorm",
    "bc7-rgba-unorm-srgb",
```

## Creating Compressed Textures

Texture compression code is usually not readily available, particulary not in JavaScript. Compression is typically done by binary programs.

loaders.gl supports texture compression under Node.js by executing a binary with the appropriate command line and then loading the output.

The `CompressedTextureWriter` uses this technique.

## IP and Patent Considerations

Traditionally an issue with compressed texture formats is that they tend to be highly propietary and patent-encumbered, and while it is usually not an issue, there can be cases where royalty requirements come into play when using them.

To side-step patent issues when using these formats a loaders.gl application would typically:

1. Generate compressed textures in external applications (which should already have licensed any required formats and libraries).
2. Load them in binary form without touching the content.
3. Pass them directly to a texture, so that they are processed inside the GPU driver (which should also habe licensed the supported formats and libraries).
